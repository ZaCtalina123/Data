#include <Wire.h>
#include <LiquidCrystal_I2C.h>

LiquidCrystal_I2C lcd(0x27, 16, 2); // Адрес 0x27 для 16x2 дисплея

// Константы игры
const int UP_BUTTON = 2;
const int DOWN_BUTTON = 3;
const char PLAYER_CHAR = 'O';
const char CACTUS_CHAR = '#';
const unsigned long FRAME_TIME = 1000 / 60; // 60 FPS (16.66 мс на кадр)

// Переменные игры
int playerPos = 0; // 0 - верхняя строка, 1 - нижняя
int score = 0;
int gameSpeed = 20; // Начальная скорость (меньше = быстрее)
int minSpeed = 8;   // Минимальная скорость
int cactusLength = 1;
bool gameOver = false;
bool spawnBothRows = false; // Может ли спавниться на двух рядах сразу

// Массив для хранения кактусов (0-15 позиции, 0-1 строки)
bool cacti[2][16] = {false};

void setup() {
  pinMode(UP_BUTTON, INPUT_PULLUP);
  pinMode(DOWN_BUTTON, INPUT_PULLUP);
  
  lcd.init();
  lcd.backlight();
  randomSeed(analogRead(0));
  
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Cactus Dodger!");
  lcd.setCursor(0, 1);
  lcd.print("Press any button");
  
  while (digitalRead(UP_BUTTON) && digitalRead(DOWN_BUTTON)) {
    delay(10);
  }
  
  lcd.clear();
}

void loop() {
  if (gameOver) {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Game Over!");
    lcd.setCursor(0, 1);
    lcd.print("Score: ");
    lcd.print(score);
    
    while (digitalRead(UP_BUTTON) && digitalRead(DOWN_BUTTON)) {
      delay(10);
    }
    
    resetGame();
    return;
  }
  
  static unsigned long lastFrameTime = 0;
  static int framesSinceLastCactus = 0;
  
  unsigned long currentTime = millis();
  if (currentTime - lastFrameTime < FRAME_TIME) {
    delay(1);
    return;
  }
  lastFrameTime = currentTime;
  
  handleInput();
  
  // Увеличиваем частоту спавна
  if (++framesSinceLastCactus >= gameSpeed) {
    generateCactus();
    framesSinceLastCactus = 0;
  }
  
  moveCacti();
  checkCollisions();
  drawGame();
}

void handleInput() {
  if (!digitalRead(UP_BUTTON)) {
    playerPos = 0;
    delay(50);
  }
  
  if (!digitalRead(DOWN_BUTTON)) {
    playerPos = 1;
    delay(50);
  }
}

void generateCactus() {
  // 70% шанс спавна кактуса (вместо 50%)
  if (random(10) < 3) return;
  
  cactusLength = random(1, 4);
  
  // С 30% шансом спавним на обоих рядах (если включено)
  bool spawnOnBoth = spawnBothRows && (random(10) < 3);
  
  // Спавн на первом ряду
  if (!spawnOnBoth || random(2) == 0) {
    int row1 = random(2);
    spawnCactusOnRow(row1);
  }
  
  // Спавн на втором ряду (если спавним на обоих)
  if (spawnOnBoth) {
    int row2 = random(2);
    spawnCactusOnRow(row2);
  }
}

void spawnCactusOnRow(int row) {
  bool spaceAvailable = true;
  for (int i = 15; i > 15 - cactusLength; i--) {
    if (i < 0 || cacti[row][i]) {
      spaceAvailable = false;
      break;
    }
  }
  
  if (spaceAvailable) {
    for (int i = 15; i > 15 - cactusLength; i--) {
      if (i >= 0) {
        cacti[row][i] = true;
      }
    }
  }
}

void moveCacti() {
  for (int row = 0; row < 2; row++) {
    for (int col = 0; col < 15; col++) {
      cacti[row][col] = cacti[row][col+1];
    }
    cacti[row][15] = false;
  }
}

void checkCollisions() {
  if (cacti[playerPos][0]) {
    gameOver = true;
  }
  
  for (int row = 0; row < 2; row++) {
    if (cacti[row][0] && row != playerPos) {
      score++;
      // Включаем спавн на двух рядах после 10 очков
      if (score == 10) spawnBothRows = true;
      // Увеличиваем сложность
      if (score % 5 == 0 && gameSpeed > minSpeed) {
        gameSpeed--;
      }
    }
  }
}

void drawGame() {
  lcd.clear();
  
  lcd.setCursor(2, playerPos);
  lcd.print(PLAYER_CHAR);
  
  for (int row = 0; row < 2; row++) {
    for (int col = 0; col < 16; col++) {
      if (cacti[row][col]) {
        lcd.setCursor(col, row);
        lcd.print(CACTUS_CHAR);
      }
    }
  }
  
  lcd.setCursor(12, 0);
  lcd.print(score);
}

void resetGame() {
  playerPos = 0;
  score = 0;
  gameSpeed = 20;
  gameOver = false;
  spawnBothRows = false;
  
  for (int row = 0; row < 2; row++) {
    for (int col = 0; col < 16; col++) {
      cacti[row][col] = false;
    }
  }
  
  lcd.clear();
}
