#include <Wire.h>
#include <LiquidCrystal_I2C.h>

LiquidCrystal_I2C lcd(0x27, 16, 2); // Адрес 0x27 для 16x2 дисплея

// Константы игры
const int UP_BUTTON = 2;
const int DOWN_BUTTON = 3;
const char PLAYER_CHAR = 'O';
const char CACTUS_CHAR = '#';
const unsigned long FRAME_TIME = 1000 / 60; // 60 FPS (16.66 мс на кадр)

// Переменные игры
int playerPos = 0; // 0 - верхняя строка, 1 - нижняя
int score = 0;
int gameSpeed = 20; // Начальная скорость (меньше = быстрее)
int minSpeed = 8;   // Минимальная скорость
int cactusLength = 1;
bool gameOver = false;
unsigned long lastMoveTime = 0;
const long moveDelay = 300; // Задержка между переключениями рядов

// Массив для хранения кактусов (0-15 позиции, 0-1 строки)
bool cacti[2][16] = {false};

void setup() {
  pinMode(UP_BUTTON, INPUT_PULLUP);
  pinMode(DOWN_BUTTON, INPUT_PULLUP);
  
  lcd.init();
  lcd.backlight();
  randomSeed(analogRead(0));
  
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Cactus Dodger!");
  lcd.setCursor(0, 1);
  lcd.print("Press any button");
  
  while (digitalRead(UP_BUTTON) && digitalRead(DOWN_BUTTON)) {
    delay(10);
  }
  
  lcd.clear();
}

void loop() {
  if (gameOver) {
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Game Over!");
    lcd.setCursor(0, 1);
    lcd.print("Score: ");
    lcd.print(score);
    
    while (digitalRead(UP_BUTTON) && digitalRead(DOWN_BUTTON)) {
      delay(10);
    }
    
    resetGame();
    return;
  }
  
  static unsigned long lastFrameTime = 0;
  static int framesSinceLastCactus = 0;
  
  unsigned long currentTime = millis();
  if (currentTime - lastFrameTime < FRAME_TIME) {
    delay(1);
    return;
  }
  lastFrameTime = currentTime;
  
  handleInput();
  
  if (++framesSinceLastCactus >= gameSpeed) {
    generateCactus();
    framesSinceLastCactus = 0;
  }
  
  moveCacti();
  checkCollisions();
  drawGame();
}

void handleInput() {
  unsigned long currentTime = millis();
  
  if (!digitalRead(UP_BUTTON) && currentTime - lastMoveTime > moveDelay) {
    playerPos = 0;
    lastMoveTime = currentTime;
  }
  
  if (!digitalRead(DOWN_BUTTON) && currentTime - lastMoveTime > moveDelay) {
    playerPos = 1;
    lastMoveTime = currentTime;
  }
}

void generateCactus() {
  // 80% шанс спавна кактуса
  if (random(10) < 2) return;
  
  cactusLength = random(1, 4);
  
  // Спавним только в ряду, где находится игрок
  spawnCactusOnRow(playerPos);
}

void spawnCactusOnRow(int row) {
  bool spaceAvailable = true;
  for (int i = 15; i > 15 - cactusLength; i--) {
    if (i < 0 || cacti[row][i]) {
      spaceAvailable = false;
      break;
    }
  }
  
  if (spaceAvailable) {
    for (int i = 15; i > 15 - cactusLength; i--) {
      if (i >= 0) {
        cacti[row][i] = true;
      }
    }
  }
}

void moveCacti() {
  for (int row = 0; row < 2; row++) {
    for (int col = 0; col < 15; col++) {
      cacti[row][col] = cacti[row][col+1];
    }
    cacti[row][15] = false;
  }
}

void checkCollisions() {
  if (cacti[playerPos][0]) {
    gameOver = true;
  }
  
  // Увеличиваем счет за каждый кадр выживания
  score++;
  
  // Увеличиваем сложность
  if (score % 100 == 0 && gameSpeed > minSpeed) {
    gameSpeed--;
  }
}

void drawGame() {
  lcd.clear();
  
  // Рисуем игрока
  lcd.setCursor(2, playerPos);
  lcd.print(PLAYER_CHAR);
  
  // Рисуем кактусы
  for (int row = 0; row < 2; row++) {
    for (int col = 0; col < 16; col++) {
      if (cacti[row][col]) {
        lcd.setCursor(col, row);
        lcd.print(CACTUS_CHAR);
      }
    }
  }
  
  // Рисуем счет
  lcd.setCursor(12, 0);
  lcd.print(score);
}

void resetGame() {
  playerPos = 0;
  score = 0;
  gameSpeed = 20;
  gameOver = false;
  lastMoveTime = 0;
  
  for (int row = 0; row < 2; row++) {
    for (int col = 0; col < 16; col++) {
      cacti[row][col] = false;
    }
  }
  
  lcd.clear();
}
